[一口气说出九种分布式id生成方案](https://mp.weixin.qq.com/s/8CGN6aeMy9UuI58ZWlUGEg)
## Id生成的系统要点
在简单系统中，我们常常使用数据表的id自增方式来标识和保存数据，随着系统的复杂，数据的增多，分库分表成为了常见的方案，db自增已无法满足要求。
这时候全局唯一的id生成系统就派上了用场。当然这只是id生成其中的一种应用场景。那么id生成系统有哪些要求呢？

1. 全局唯一的id:无论怎样都不能重复，这是最基本的要求了
2. 高性能:基础服务尽可能耗时少，如果能够本地生成最好
3. 高可用:虽说很难实现100%的可用性，但是也要无限接近于100%的可用性
4. 简单易用: 能够拿来即用，接入方便，同时在系统设计和实现上要尽可能的简单

## 分布式id生成的几种实现方式
### 利用db的auto_increment
用一个单独的数据库实例建一张表，每次获取id就向该表插入一条数据，利用id自增，每次返回当前id。缺点是每次只能返回一个id，性能较差。对数据库
的访问比较频繁，db的压力大。是否可以优化一下？

### db号段算法
设置一个长度，每次获取该长度的一段号码，用完了再更新，取下一段。

| id      | biz_type | max_id | step | version |
| --------| :------: | :----: | :---:| :------:|
| 1       | 02       | 2000   | 1000 | 0       |
- biz_type代表业务类型，不同的业务的id隔离
- max_id代表当前最大的可用id
- step代表号段的长度，可以根据每个业务的qps来设置一个合理的长度
- version是一个乐观锁，每次更新都加上version，能够保证并发更新的正确性
 
那么我们可以通过如下几个步骤来获取一个可用的号段:
1. 查询当前的max_id信息：select id, biz_type, max_id, step, version from tiny_id_info where biz_type='test';
2. 计算新的max_id: new_max_id = max_id + step
3. 更新DB中的max_id：update tiny_id_info set max_id=#{new_max_id} , verson=version+1 where id=#{id} and max_id=#{max_id} and version=#{version}
4. 如果更新成功，则可用号段获取成功，新的可用号段为(max_id, new_max_id]
5. 如果更新失败，则号段可能被其他线程获取，回到步骤A，进行重试

### 号段模式简单架构图

![](https://github.com/didi/tinyid/raw/master/doc/tinyid-easy.png)

### 存在的问题
- 存在tiny-server重启或宕机了，号段就丢失了，会浪费一部分id
- 同时id也不会连续；每次请求可能会打到不同的机器上，id也不是单调递增的，而是趋势递增的，不过这对于大部分业务都是可接受的。
- db是一个单点，虽然db可以建设主从等高可用架构，但始终是一个单点
- 使用http方式获取一个id，存在网络开销，性能和可用性都不太好

### 滴滴TinyId
基于号段算法，增加了以下功能：
- 多db配置，多主集群模式，只要有一个数据库可用，服务就可用
- tiny-client，客户端调用方式，只有获取号段的时候需要http调用，号段缓存在客户端本地。代替每次获取id都需要http调用，减少了开销，性能更好。
- 针对号段用完，需要访问DB，对DB还是有可能有压力。引入了双号段缓存，当第一个号段使用了一定数量时，
异步加载另一个号段做备用。第一个号段用完则切换到备用号段

### 雪花算法snowflake
我们可以换个角度来对分布式ID进行思考，只要能让负责生成分布式ID的每台机器在每毫秒内生成不一样的ID就行了。
snowflake是twitter开源的分布式ID生成算法，是一种算法，所以它和上面的三种生成分布式ID机制不太一样，它不依赖数据库。
核心思想是：分布式ID固定是一个long型的数字，一个long型占8个字节，也就是64个bit，原始snowflake算法中对于bit的分配如下:
- 第一个bit位是标识部分，在java中由于long的最高位是符号位，正数是0，负数是1，一般生成的ID为正数，所以固定为0。
- 时间戳部分占41bit，这个是毫秒级的时间，一般实现上不会存储当前的时间戳，而是时间戳的差值（当前时间-固定的开始时间），这样可以使产生的ID从更小值开始；41位的时间戳可以使用69年，(1L << 41) / (1000L * 60 * 60 * 24 * 365) = 69年
- 工作机器id占10bit，这里比较灵活，比如，可以使用前5位作为数据中心机房标识，后5位作为单机房机器标识，可以部署1024个节点。
- 序列号部分占12bit，支持同一毫秒内同一个节点可以生成4096个ID

### 百度uid-generator
uid-generator是基于Snowflake算法实现的，与原始的snowflake算法不同在于，uid-generator支持自定义时间戳、工作机器ID和 序列号 等各部分的位数，而且uid-generator中采用用户自定义workId的生成策略。
uid-generator需要与数据库配合使用，需要新增一个WORKER_NODE表。当应用启动时会向数据库表中去插入一条数据，插入成功后返回的自增ID就是该机器的workId数据由host，port组成。
对于uid-generator ID组成结构：
workId，占用了22个bit位，时间占用了28个bit位，序列化占用了13个bit位，需要注意的是，和原始的snowflake不太一样，时间的单位是秒，而不是毫秒，workId也不一样，而且同一应用每次重启就会消费一个workId。
### 美团leaf
[美团Leaf](https://tech.meituan.com/2017/04/21/mt-leaf.html)
Leaf同时支持号段模式和snowflake算法模式，可以切换使用。

#[JVM总结](https://juejin.im/post/6856958647445291021)

